<%- include("partials/header.ejs") %>

<h1>6 Common Mistakes in JavaScript a Mid-Senior Developer Should Know and Tackle</h1>
<h2>JavaScript Mistake #1: Working Without a Coding Style Guide</h2>
<p>
    Probably the mother of all bugs in JavaScript begins when you start a project without defining a JS coding style. It’s very common to have certain rules with your team regarding how to write the JS code in a uniform way. It is important to remember that there are several bad practices and common JavaScript errors that are actually included by default in these styles. If you don’t address this upfront, the code written by the team members will vary considerably and will lead to several errors. These JavaScript bugs will be difficult to notice and review from a pull request (PR) before being actually merged with the main/master base code.
</p>
<p>
    So, the idea is to use a linter to ensure that all members of the team follow these rules and avoid common JS mistakes. Here is an example of Standard and AirBnB style code:
</p>
<h3>Standard Style</h3>
<p>
    <b>Rule > eslint: no-this-before-super</b><br>
    Description: <code>super()</code> must be called before using <code>this</code>.
</p>
<pre>
class Dog extends Animal {
    constructor() {
        this.legs = 4; // avoid this
        super();
    }
}
</pre>
<h3>Airbnb Style</h3>
<p>
    <b>Rule > 3.4 Use property value shorthand. ESLint: object-shorthand</b><br>
    Why? It is shorter and more descriptive.
</p>
<pre>
function getKey(k) {
    return `a key named ${k}`;
}
// bad
const obj = {
id: 5,
name: 'San Francisco',
};
obj[getKey('enabled')] = true;

// good
const obj = {
id: 5,
name: 'San Francisco',
[getKey('enabled')]: true,
};
</pre>

<p>
    To include these marvelous killers of bugs in JavaScript, the best method is to use the ESLint package. The key, though, is to define with your team which style of code will be chosen and maintained throughout the project.
</p>
<p>
    Your decision will be configured using the ESLint rules, or you could base it on current renowned JS style guides like Standard, AirBnB, or Google. Additionally, it’s critical to ensure that this is successfully integrated with the IDE used by all the team members to verify whether the written code has style errors. A better approach might be to use an automatic tool to refactor the code according to the rules, like Prettier (probably the unopinionated tool for that purpose).
</p>
<h2>JavaScript Mistake #2: Using Magic Values</h2>
<p>
    Using magic values is a common mistake in multiple languages, but in JS it’s definitely a mistake you should avoid. First of all, a magic value is considered a constant value that magically appears in the code, and probably only those who wrote the code could easily explain what it does, and usually, even they forgot it. XD 
</p>
<p>Example:</p>
<p>With magic values:</p>
<pre>
const specialFn = (r) => {
    const fnValue = 2 * 3.1416 * r; // not clear :/
    return fnValue;
};
console.log(specialFn(4));
</pre>
<p>The right way:</p>
<pre>
const PI = 3.1416;
const specialFn = (r) => {
    const fnValue = 2 * PI * r; // Looks like circumference :)
    return fnValue;
};
console.log(specialFn(4));
</pre>
<p>
    This approach basically applies to everything that could be considered a constant, not only numbers but to names, prefixes, etc.
</p>
<h2>JavaScript Mistake #3: Disregarding Object Mutability (or Mutating in a Cluttered Way)</h2>
<p>
    <code>const</code> does not imply that the object is not mutable, as some people assume. The issue with mutability does not end here. If you want to be more strict with mutability, there are many other considerations to keep in mind.
</p>
<p>
    For example, the use of this mutability approach requires extra space because it involves several clones of mutated data. Although this approach is commonly used in Functional Programming approaches, it is important to be aware of the spatial complexity to avoid memory leaks, as will be discussed in mistake #6.
</p>
<h2>JavaScript Mistake #4: Failing to Handle Errors Correctly</h2>
<p>
    Handling errors correctly is not limited to using the try-catch statement. It is very important to recognize how to use the exceptions and how to catch and handle the errors in a clever and safe way.
</p>
<p>
    To do so it’s important to recognize there are some differences between an Error and an Exception, even though most of the time, JS developers refer to them as if they are practically the same.
</p>
<p>
    An Error can be considered as an unexpected response of the program. An Error can happen in different phases, for example during compilation time (usually Syntax errors), or running time also called runtime errors.
</p>
<p>Examples of execution errors in JS:</p>
<p>RangeError: invalid array length</p>
<pre>
const invalidArrayNegative = new Array(-1);
const invalidArrayDecimal = new Array(1.2);
</pre>
<p>Link: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length">MDN: Invalid array length</a></p>
<p>TypeError: 'x' is not iterable</p>
<pre>
let nonIterable = 123;
for (let number of nonIterable) {
    console.log(number);
}
</pre>
<p>Link: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/is_not_iterable">MDN: 'x' is not iterable</a></p>
<p>
    In addition to runtime errors, there is another type called logical errors, which are related to how the program is expected to work.
</p>
<p>
    But it is important to clarify that an error can actually crash the execution of a script or the call of an event handler, but the correct catch will transform these errors/exceptions (JavaScript throw error) into a handled exception.
</p>
<p>
    Exceptions are considered errors that are expected or almost expected to be handled in order to avoid the interruption of the flow of the program execution.
</p>
<p>Example of an exception catch and handling:</p>
<pre>
let nonIterable = 123;
try {
    for (let number of nonIterable) {
        console.log(number);
    }
} catch (e) {
    if (e instanceof ReferenceError) {
        console.log("Handle in some way...");
    } else {
        console.log(e.message, e.name);
    }
}
</pre>
<p>
    This is a good example of how to handle an error as an exception using the specific type of error to handle specific types of bugs in a certain way, and others differently.
</p>
<p>
    Other kinds of errors include syntax errors and type errors, which are usually prevented using linters, as mentioned above, or using the strict mode, and transpilers (like Babel for example).
</p>
<p>
    The need to customize error types allows for better handling of these special cases into tailor-made exceptions. Since ES6 there is an easy way to do it, extending the Error Object and creating custom error types.
</p>
<pre>
class MyOwnError extends Error {
    constructor(message = 'Custom error') {
        super();
        this.name = 'MyOwnError';
        this.message = message;
    }
}
try {
    throw new MyOwnError('Special exception');
} catch (e) {
    if (e instanceof MyOwnError) {
        console.log('Custom exception:', e.name, e.message);
    } else {
        console.log("Other error", e.message);
    }
}
</pre>
<p>
    More info:
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#custom_error_types">MDN: Custom error types</a>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#exception_handling_statements">MDN: Exception handling statements</a>
</p>
<h2>JavaScript Mistake #5: Not Using Any Kind of Typing or “Static Typing”</h2>
<p>
    This could be covered in a separate article, but for now, just know that there are options to avoid some bugs in JavaScript resulting from the absence of types.
</p>
<p>
    The first one is to use TypeScript. Since TS was released, its main objective was to provide static typing to JS using several syntax sugar features to guarantee the types should be maintained and for developers more familiar with other languages. It’s important to mention that TS is basically a superset of JS, which means, you could use JS inside TS because TS is JS too, but with types and some syntax sugar added.
</p>
<p>
    There are other options, like using Flow directly with Vanilla JS, and more rudimentary approaches using JSDocs as part of the IDE, which is basically using JS with the types working like a lint inside the IDE.
</p>
<h2>JavaScript Mistake #6: Creating Memory Leaks</h2>
<p>
    A memory leak is easy to recognize at runtime when you monitor your server instances and see the average memory consumption increase. The first thing someone might think of doing is increasing the default memory limit of Node.js from the 1.4Gb using the classic environment variable modification like this:
</p>
<pre>
'NODE_OPTIONS="--max-old-space-size=2048"'
</pre>
<p>
    But that never solves the main question, which is “why is the memory consumption so high”?
</p>
<p>
    There are several articles regarding this situation, and here, I will cover just one very common case based on my experience.
</p>
<p>
    You probably made a “functional” code, which usually works well for a basic unit test, but what if you included only the happy path test cases, and some edge cases, could that be the cause of the memory leaks?
</p>
<p>
    That’s the point of using arrays to manage collections, saving in-memory massive collections like arrays to iterate them afterward.
</p>
<p>Code example:</p>
<pre>
const arr = Array.from({ length: 1000 }).fill(0);
const arr2 = arr.map((el) => {
    // Perform some transformation
    return el + 1;
});
//...
// other code
//...

const arr3 = arr2.map((el) => {
// Perform some transformation
return el + 3;
});
</pre>

<p>The example above is a good way to show how with a map we can perform a simple transformation for a map, but cloning it. For a little array, the memory consumption is insignificant, but with greater arrays, we would easily find a big memory impact.</p>
<p>Solution: Understand that you are exceeding your space complexity for big arrays (this is a CS concept we didn’t cover here but that could be covered in another article). A good idea is to split in chunks the arrays you are working with. Identify possible extra copies of those arrays, understanding where a no mutation approach with a map would be better, or where an in-place transformation would be best (unless you have to do it with an FP approach).</p>
<p>So, another good option is to chain the maps, avoiding multiple clonings:</p>
<pre>
const arr = Array.from({ length: 1000 }).fill(0);
const arr2 = arr.map((el) => {
    // Perform some transformation
    return el + 1;
}).map((el) => {
    // Perform some transformation
    return el + 3;
});
</pre>
<p>Or, if possible, reduce the number of maps and cloning of these arrays using a reducer approach like this:</p>
<pre>
const arr = Array.from({ length: 1000 }).fill(0);
const arr2 = arr.reduce((accumulator, current_el) => {
    // Perform any other kind of transformations and
    // even aggregations
    accumulator.push(current_el + 4);
    return accumulator;
}, []);
console.log(arr2);
</pre>
<%- include("partials/footer.ejs") %>